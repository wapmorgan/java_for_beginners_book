# Приложение А
# Ответы на вопросы для самопроверки

## Глава 1. Основы Java
1.  Что такое байт-код и почему он так важен для интернет-программирования на язы¬
ке Java?
Байт-код — это высокооптимизированный набор инструкций, выполняемых под
управлением интерпретатора Java. Байт-код позволяет добиться переносимости
и безопасности программ, написанных на этом языке программирования.
2.  Каковы три основных принципа объектно-ориентированного программирования?
Инкапсуляция, полиморфизм и наследование.
3.  С чего начинается выполнение программы на Java?
Выполнение программы на Java начинается с метода main ().
4.  Что такое переменная?
Переменная — это именованная область памяти. Содержимое переменной может
изменяться в процессе выполнения программы.
5.  Какое из перечисленных ниже имен переменных недопустимо?
A.  count
B.  $count
C.  count27
D.  67count
Недопустимо имя переменной 67count (пункт D). Имя переменной не может на¬
чинаться с цифры.
6.  Как создать однострочный комментарий? И как создать многострочный коммента¬
рий?
Однострочные комментарии должны начинаться с символов / /.В этом случае ком¬
ментариями считаются эти и все последующие символы до конца строки. А много¬
строчные комментарии должны начинаться символами / * и заканчиваться симво¬
лами */.
7.  Как выглядит общая форма условного оператора if? И как выглядит общая форма
цикла for?
Общая форма оператора i f выглядит следующим образом:
if (условие) оператор;
А общая форма цикла for имеет следующий вид:
for (инициализация; условие; итерация) оператор;
8.  Как создать кодовый блок?
Кодовый блок должен начинаться с символа { и завершаться символом }.
9.  Сила тяжести на Луне составляет около 17% земной. Напишите программу, которая
вычисляла бы ваш вес на Луне.
/*
Вычисление веса на Луне.
Присвоить ее исходному файлу имя Moon.java.
*/
Приложение А. Ответы на вопросы для самопроверки 557.
class Moon {
public static void main(String args[]) {
double earthweight; // Вес на Земле
double moonweight; // Вес на Луне
earthweight = 165;
moonweight = earthweight * 0.17;
System.out.println(earthweight +
" earth-pounds is equivalent to " +
moonweight + " moon-pounds.");
}
}
10. Видоизмените программу, созданную в примере для опробования 1.2, таким обра¬
зом, чтобы она выводила таблицу преобразования дюймов в метры. Выводите зна¬
чения длины до 12 футов через каждый дюйм. После каждых 12 дюймов выводите
пустую строку. (Один метр приблизительно равен 39,37 дюйма.)
/*
Эта программа отображает таблицу преобразования дюймов в метры.
Присвоить ее исходному файлу имя InchToMeterTable.java.
*/
class InchToMeterTable {
public static void main(String args[]) {
double inches, meters;
int counter;
counter = 0;
for(inches = 1; inches <= 144; inches++) {
meters = inches / 39.37; // преобразовать в метры
System.out.println(inches + " inches is " +
meters + " meters.");
counter++;
// Каждая 12-я выводимая строка должна быть пустой
if(counter == 12)   {
System.out.println();
counter =0; // сбросить счетчик строк
}
}
}
}
11. Если при вводе кода программы вы допустите опечатку, то какого рода сообщение
об ошибке вы получите?
Сообщение о синтаксической ошибке.
12. Имеет ли значение, в каком именно месте строки находится оператор? Не имеет.
В Java допускается произвольное форматирование исходного кода.

## Глава 2. Введение в типы данных и операторы
1.  Почему в Java строго определены диапазоны допустимых значений и области дей¬
ствия простых типов?
Диапазоны допустимых значений и области действия простых типов строго опреде¬
лены в Java для того, чтобы обеспечить переносимость программ с одной платфор¬
мы на другую.
2.  Что собой представляет символьный тип в Java и чем он отличается от символьного
типа в ряде других языков программирования?
Символьный тип задается ключевым словом char. В Java для представления симво¬
лов применяется уникод (Unicode), в отличие от многих других языков программи¬
рования, в которых для этой цели применяется код ASCII.
3.  Переменная типа boolean может иметь любое значение, поскольку любое ненуле¬
вое значение интерпретируется как истинное. Верно или неверно?
Неверно. Переменная типа boolean может принимать лишь одно из двух логиче¬
ских значений: true или false.
4.  Допустим, результат выполнения программы выглядит следующим образом:
One
Two
Three
Напишите строку кода с вызовом метода println (), где этот результат выводится
в одной символьной строке.
System.out.println("One\nTwo\nThree");
5.  Какая ошибка допущена в следующем фрагменте кода:
for(i = 0; i < 10; i++) {
int sum;
sum = sum + i;
}
System.out.println("Sum is: " + sum);
В этом фрагменте кода имеются две существенные ошибки. Во-первых, перемен¬
ная sum создается на каждом шаге цикла for, а следовательно, в промежутке между
последовательными итерациями предыдущее значение подсчитываемой суммы не
будет сохраняться в этой переменной. И во-вторых, переменная sum недоступна за
пределами кодового блока, в котором она объявлена. Поэтому ссылка на нее при
вызове метода println () недопустима.
6.  Поясните отличие между префиксной и постфиксной формами оператора инкре¬
мента.
Если оператор инкремента предшествует операнду, исполняющая система Java вы¬
полнит операцию до извлечения значения операнда и использования его в осталь¬
ной части выражения. Если же оператор инкремента следует за операндом, испол¬
няющая система сначала извлечет значение операнда и лишь затем инкрементирует
сам операнд.
7.  Покажите, каким образом укороченный логический оператор И может предотвра¬
тить деление на нуль.
if((b != 0) && (val / b))   ...
Приложение А. Ответы на вопросы для самопроверки 559.
8.  К какому типу продвигаются типы byte и short при вычислении выражения?
В выражении типы byte и short продвигаются к типу int.
9.  Когда возникает потребность в явном приведении типов?
Явное приведение типов требуется при обращении с несовместимыми типами или в
том случае, если преобразование типов приводит к сужению диапазона допустимых
значений.
10. Напишите программу, которая находила бы простые числа в пределах от 2 до 100.
// Нахождение простых чисел в пределах от 2 до 100.
class Prime {
public static void main(String args[]) {
int i, j;
boolean isprime;
for(i=2; i < 100; i++) {
isprime = true;
// проверить, делится ли число без остатка
for(j=2; j < i/j; j++)
// если число делится без остатка, значит, оно простое
if ( (i%j) == 0) isprime = false;
if(isprime)
System.out.println(i + " is prime.");
}
}
}
11. Влияют ли лишние скобки на эффективность выполнения программ?
Нет, не влияют.
12. Определяет ли кодовый блок область действия переменных?
Да, определяет.

## Глава 3. Управляющие операторы
1.  Напишите программу, которая вводила бы символы с клавиатуры до тех пор, пока
не встретится точка. Предусмотрите в программе счетчик числа пробелов. Сведения
о количестве пробелов должны выводиться в конце программы.
// Подсчет пробелов,
class Spaces {
public static void main(String args[])
throws java.io.IOException {
char ch;
int spaces = 0;
System.out.println("Enter a period to stop.");
do {
ch = (char) System.in.read();
560 Java 7: руководство для начинающих, 5-е издание
if(ch == 1 ') spaces++;
} while (ch ! =
System.out.println("Spaces: " + spaces);
}
}
2.  Какова общая форма многоступенчатой конструкции if-else-if?
if(условие)
оператор;
else if{условие)
оператор;
else if(условие)
оператор;
else
оператор;
3.  Допустим, имеется следующий фрагмент кода:
if (х < 10)
if(у > 100) {
if(!done) х = z;
else у = z;
}
else System.out.println("error"); // что если?
С каким из операторов if связан последний оператор else?
Последний оператор else соответствует билижайшему оператору if того же уровня,
т.е. if (у > 100).
4.  Напишите цикл for, в котором перебирались бы значения от 1000 до 0 с шагом -2.
for(int i = 1000; i >= 0; i -= 2) // ...
5.  Корректен ли следующий фрагмент кода?
for(int i = 0; i < num; i++)
sum += i;
count = i;
Нет, не корректен. Переменная i недоступна за пределами цикла for, в котором
она объявлена.
6.  Какие действия выполняет оператор break? Опишите оба рарианта этого оператора.
Оператор break без метки вызывает немедленное завершение текущего цикла или
выражения switch. А оператор break с меткой передает управление в конец по¬
меченного блока.
7.  Какое сообщение будет выведено после выполнения оператора break в приведен¬
ном ниже фрагменте кода?
for(i = 0; i < 10; i++) {
while(running) {
if(x<y) break;
// ...
Приложение А. Ответы на вопросы для самопроверки £61
}
System.out.println("after while");
}
System.out.println("After for");
После выполнения оператора break будет выведено сообщение "after while"
(после цикла while).
8.  Что будет выведено на экран в результате выполнения следующего фрагмента кода?
for (int i = 0; i<10; i++) {
System.out.print(i + " ");
if((i%2) == 0) continue;
System.out.println();
}
На экране появится следующий результат:
о 1
2   3
4 5
6 7
8 9
9.  Итерационное выражение для цикла for не обязательно должно изменять перемен¬
ную цикла на фиксированную величину. Эта переменная может принимать произ¬
вольные значения. Напишите программу, использующую цикл for для вывода чисел
в геометрической прогрессии 1, 2, 4, 8, 16, 32 и т.д.
/* Применение цикла for для формирования
геометрической прогрессии 1, 2, 4, 8, 16, 32 и т.д.
*/
class Progress {
public static void main(String args[]) {
for(int i = 1; i < 100; i += i)
System.out.print(i + " ");
}
}
10. Код ASCII-символов нижнего регистра отличается от кода соответствующих симво¬
лов верхнего регистра на величину 32. Следовательно, для преобразования строчной
буквы в прописную нужно уменьшить ее код на 32. Используйте это обстоятельство
для написания программы, осуществляющей ввод символов с клавиатуры. При вы¬
воде результатов данная программа должна преобразовывать строчные буквы в про¬
писные, а прописные — в строчные. Остальные символы не должны изменяться.
Работа программы должна завершаться после того, как пользователь введет с клави¬
атуры точку. И наконец, сделайте так, чтобы программа отображала число символов,
для которых был изменен регистр.
// Смена регистра символов,
class CaseChg {
public static void main(String args[])
throws java.io.IOException {
char ch;
int changes = 0;
System.out.println("Enter period to stop.");
do {
ch = (char) System.in.read();
if(ch >= 'a' & ch <= 'z')   {
ch -= 32;
changes++;
System.out.println(ch);
}
else if(ch >= 'A' & ch <= 'Z')  {
ch += 32;
changes++;
System.out.println(ch);
}
} while(ch != '.');
System.out.println("Case changes: " + changes);
}
}
11. Что такое бесконечный цикл?
Бесконечным называется такой цикл, выполнение которого не оканчивается.
12. Должна ли метка, используемая вместе с оператором break, быть определена в ко¬
довом блоке, содержащем этот оператор?
Да, должна.

## Глава 4. Введение в классы, объекты и методы
1.  В чем отличие класса от объекта?
Класс — это абстрактное логическое описание формы и поведения объекта. А объ¬
ект — это вещественный экземпляр класса.
2.  Как определяется класс?
Класс определяется с помощью ключевого слова class. В операторе class указы¬
ваются код и данные, составляющие класс.
3.  Чью собственную копию содержит каждый объект?
Каждый объект класса содержит собственную копию переменных экземпляра этого
класса.
4.  Покажите, как объявить объект counter класса MyCounter, используя два отдель¬
ных оператора.
MyCounter counter;
counter = new MyCounter();
5.  Как должен быть объявлен метод myMeth, принимающий два параметра а и b типа
int и возвращающий значение типа double?
double myMeth(int a, int b) { // ...
6.  Как должно завершаться выполнение метода, возвращающего некоторое значение?
Для завершения метода служит оператор return. Он же передает возвращаемое зна¬
чение вызывающей части программы.
7.  Каким должно быть имя конструктора?
Приложение А. Ответы на вопросы для самопроверки 563
Имя конструктора должно совпадать с именем класса.
8.  Какие действия выполняет оператор new?
Оператор new выделяет память для объекта и выполняет инициализацию объекта,
используя конструктор соответствующего класса.
9.  Что такое “сборка мусора” и какие действия она выполняет? Зачем нужен метод
finalize()?
“Сборка мусора” — это механизм удаления неиспользуемых объектов для повторно¬
го использования памяти, освобождаемой от объектов. Метод finalize () вызыва¬
ется для объекта непосредственно перед его удалением из памяти.
10. Что означает ключевое слово this?
Ключевое слово this означает ссылку на объект, для которого вызывается метод.
Она автоматически передается методу.
11. Может ли конструктор иметь один или несколько параметров?
Да, может.
12. Если метод не возвращает значения, то как следует объявить тип этого метода?
Как void.

## Глава 5. Дополнительные сведения
о типах данных и операторах
1.  Покажите два способа объявления одномерного массива, состоящего из 12 элемен¬
тов типа double.
double х[] = new double[12];
doublet] x = new double[12];
2.  Покажите, как инициализировать одномерный массив целочисленными значения¬
ми от 1 до 5.
int х[] = { 1, 2, 3, 4, 5 };
3.  Напишите программу, в которой массив используется для нахождения среднего
арифметического десяти значений типа double. Используйте любые десять чисел.
// Среднее арифметическое 10 значений типа double,
class Avg {
public static void main(String args[]) {
double nums[] = { 1.1, 2.2, 3.3, 4.4, 5.5,
6.6, 7.7, 8.8, 9.9, 10.1 };
double sum = 0;
for(int i=0; i < nums.length; i++)
sum += nums[i];
System.out.println("Average: " + sum / nums.length);
}
}
4.  Измените программу, созданную в примере для опробования 5.1, таким образрм,
чтобы она сортировала массив символьных строк. Продемонстрируйте ее работо¬
способность.
564 Java 7: руководство для начинающих, 5-е издание
// Демонстрация пузырьковой сортировки строк,
class StrBubble {
public static void main(String args[]) {
String strs[] = {
"this", "is", "a", "test",
"of", "a", "string", "sort"
};
int a, b;
String t;
int size;
size = strs.length; // Количество сортируемых элементов
// отобразить исходный массив
System.out.print("Original array is:");
for (int i=0; i < size; i++)
System.out.print(" " + strs[i]);
System.out.println();
// Пузырьковая сортировка строк.
for(a=l; a < size; a++)
for(b=size-l; b >= a; b—)   {
// поменять элементы местами при нарушении порядка их следования
if(strs[b—1].compareTo(strs[b]) > 0) {
t = strs[b-1];
strs[b-l] = strs[b];
strs[b] = t;
}
}
// отобразить отсортированный массив
System.out.print("Sorted array is:");
for (int i=0; i < size; i++)
System.out.print(" " + strs[i]);
System.out.println();
}
}
5.  В чем отличие методов indexOf () и lastIndexOf () из класса String?
Метод indexOf () находит первое вхождение указанной подстроки, а метод
lastlndexOf () — ее последнее вхождение в текущей символьной строке.
6.  Все символьные строки являются объектами типа String. Покажите, как вызыва¬
ются методы length () и charAt () для строкового литерала ”1 like Java" (Мне
нравится Java).
Как ни странно, приведенный ниже вызов метода length () вполне допустим.
System.out.println("I like Java".length());
В результате этого вызова на экран выводится значение 11. Аналогичным образом
вызывается и метод charAt ().
7.  Расширьте класс Encode таким образом, чтобы в качестве ключа шифрования ис¬
пользовалась строка из восьми  символов.
Приложение А. Ответы на вопросы для самопроверки 565
// Видоизмененный способ шифрования и дешифрования сообщений
// с помощью операции поразрядного исключающего ИЛИ.
class Encode {
public static void main(String args[]) {
String msg = "This is a test";
String encmsg = "";
String decmsg = "";
String key = "abcdefgi";
int j;
System.out.print("Original message: ");
System.out.println(msg);
// зашифровать сообщение
j = 0;
for(int i=0; i < msg.length(); i++) {
encmsg = encmsg + (char) (msg.charAt(i) A key.charAt(j));
j++;
if(j==8) j = 0;
}
System.out.print("Encoded message: ");
System.out.println(encmsg);
// дешифровать сообщение
j = 0;
for(int i=0; i < msg.length(); i++) {
decmsg = decmsg + (char) (encmsg.charAt(i) л key.charAt(j));
j++;
if(j==8) j = 0;
}
«
System.out.print("Decoded message: ");
System.out.println(decmsg);
}
}
8.  Можно ли применять поразрядные операторы к значениям типа double?
Нет, нельзя.
9.  Перепишите приведенную ниже последовательность операторов, воспользовавшись
оператором ?.
if(х < 0) у = 10;
else у = 20;
Ответ:
у = х < 0 ? 10 : 20;
10. В приведенном ниже фрагменте кода содержится знак &. Какой оператор он обозна¬
чает: поразрядный или логический? Обоснуйте свой ответ.
boolean а, Ь;
// ...
if(а & Ь) ...
566 Java 7: руководство для начинающих, 5-е издание
Это логический оператор, поскольку оба его операнда относятся к типу boolean.
11. Является ли ошибкой превышение верхней границы массива?
Да.
Является ли ошибкой использование отрицательных значений для доступа к эле¬
ментам массива?
Да. Значения индексов массива начинаются с нуля.
12. Как обозначается оператор сдвига вправо без знака?
»>
13. Перепишите рассмотренный ранее в этой главе класс MinMax таким образом, чтобы
в нем использовалась разновидность for-each цикла for.
// Нахождение минимального и максимального значений в массиве,
class MinMax {
public static void main(String args[]) {
int nums[] = new int[10];
int min, max;
nums[0] = 99;
nums[l] = -10;
nums[2] = 100123;
nums[3] = 18;
nums[4] = -978;
nums[5] = 5623;
nums[6] = 4 63;
nums[7] = -9;
nums[8] = 287;
nums[9] = 4 9;
min = max = nums[0];
for(int v : nums) {
if(v < min) min = v;
if(v > max) max = v;
}
System.out.println("min and max: " + min + " " + max);
}
}
14. В примере для опробования 5.1 была реализована пузырьковая сортировка. Можно
ли в программе из этого примера заменить обычный цикл for его разновидностью
for-each? Если нельзя, то почему?
Циклы for, выполняющие сортировку в классе Bubble, нельзя преобразовать в ва¬
риант for-each. Что касается внешнего цикла, то текущее значение его перемен¬
ной используется во внутреннем цикле. А что касается внутреннего цикла, то для
перестановки следующих не по порядку элементов требуются операции присваива¬
ния значений элементам массива, чего нельзя добиться в варианте for-each.
15. Можно ли управлять оператором switch с помощью объектов типа String?
Можно, начиная с версии JDK 7.

## Глава 6. Дополнительные сведения
о методах и классах
1.  Допустим, имеется следующий фрагмент кода:
class X {
private int count;
Является ли допустимым приведенный ниже фрагмент кода?
class Y {
public static void main(String args[]) {
X ob = new X();
ob.count = 10;.
Нет. Закрытый (private) член недоступен за пределами своего класса.
2.  Модификатор доступа должен  объявлению члена класса.
предшествовать
3.  Помимо очереди, в программах часто используется структура данных, которая назы¬
вается стеком. Обращение к стеку осуществляется по принципу “первым пришел —
последним обслужен“. Стек можно сравнить со стопкой тарелок, стоящих на столе.
Последней берется тарелка, поставленная на стол первой. Создайте класс Stack, ре¬
ализующий стек для хранения символов. Используйте методы push () и pop () для
манипулирования содержимым стека. Пользователь класса Stack должен иметь воз¬
можность задавать размер стека при его создании. Все члены класса Stack, кроме
методов push () и pop (), должны быть объявлены как private. (Подсказка: в каче¬
стве заготовки можете воспользоваться классом Queue, изменив в нем лишь способ
доступа к данным.)
// Класс, реализующий стек для хранения символов,
class Stack {
private char stck[]; // Массив для хранения элементов стека
private int tos;    // Вершина стека.
// построить пустой стек заданного размера
Stack(int size) {
stck = new char[size]; // выделить память для стека
tos = 0;
}
// построить один стек из другого стека
Stack(Stack ob) {
tos = ob.tos;
stck = new char[ob.stck.length];
// скопировать элементы
for(int i=0; i < tos; i++)
stck[i] = ob.stck[i];
}
// построить стек с исходными значениями
Stack(char а[]) {
568 Java 7: руководство для начинающих, 5-е издание
stck = new char[a.length];
for(int i = 0; i < a.length; i++) {
push(a[i]);
}
}
// поместить символы в стек
void push(char ch) {
if(tos==stck.length) {
System.out.println(" — Stack is full.");
return;
}
stck[tos] = ch;
tos++;
}
// извлечь символы из стека
char pop()  {
if(tos==0)  {
System.out.println(" — Stack is empty.");
return (char) 0;
}
tos—;
return stck[tos];
}
}
// продемонстрировать применение класса Stack
class SDemo {
public static void main(String args[]) {
// создать пустой стек на 10 элементов
Stack stkl = new Stack(lO);
char name[] = {'T1, 'o',    'm'};
// построить стек из массива
Stack stk2 = new Stack(name);
char ch;
int i;
// поместить символы в стек stkl
for(i=0; i < 10; i++)
stkl.push((char) ('A' + i));
// построить один стек из другого стека
Stack stk3 = new Stack(stkl);
// отобразить стеки
System.out.print("Contents of stkl: ");
for(i=0; i < 10; i++) {
ch = stkl.pop();
System.out.print(ch);
}
System.out.println("\n");
System.out.print("Contents of stk2: ");
for(i=0; i < 3; i++) {
ch = stk2.pop();
System.out.print(ch);
}
System.out.println("\n");
System.out.print("Contents of stk3: ");
for(i=0; i < 10; i++)   {
ch = stk3.pop();
System.out.print(ch);
}
}
}
Ниже приведен результат выполнения данной программы.
Contents of stkl: JIHGFEDCBA
Contents of stk2: moT
Contents of stk3: JIHGFEDCBA
4.  Допустим, имеется следующий класс:
class Test {
int a;
Test(int i) { a = i; }
}
Напишите метод swap (), реализующий обмен содержимым между двумя объектами
типа Test, на которые ссылаются две переменные данного типа.
void swap(Test obi, Test ob2) {
int t;
t = obi.a;
obi.a = ob2.a;
ob2.a = t;
}
5.  Правильно ли написан следующий фрагмент кода?
class X {
int meth(int a, int b) { ... }
String meth(int a, int b) { ... }
Нет, неправильно. Перегружаемые методы могут возвращать значения разного типа,
но это не играет никакой роли для определения подобных методов во время их пе¬
регрузки. Перегружаемые методы должны иметь в своих списках разнотипные пара¬
метры.
6.  Напишите рекурсивный метод, отображающий строку задом наперед.
57О Java 7: руководство для начинающих, 5-е издание
// Отображение строки задом наперед с помощью рекурсии,
class Backwards {
String str;
Backwards(String s) {
str = s;
}
void backward(int idx) {
if(idx != str.length()-1) backward(idx+1);
System.out.print(str.charAt(idx) ) ;
}
}
class BWDemo {
public static void main(String args[]) {
Backwards s = new Backwards("This is a test");
s.backward(0);
}
}
7.  Допустим, что все объекты класса должны совместно пользоваться одной и той же
переменной. Как объявить такую переменную?
Переменная, предназначенная для совместного использования, должна быть объяв¬
лена как static.
8.  Для чего может понадобиться статический блок?
Статический блок служит для выполнения любых инициализирующих действий в
классе до создания конкретных объектов.
9.  Что такое внутренний класс?
Внутренний класс — это нестатический вложенный класс.
10. Допустим, требуется член класса, к которому могут обращаться только другие члены
этого же класса. Какой модификатор доступа следует использовать в его объявле¬
нии?
Модификатор доступа private.
11. Имя метода и список его параметров вместе составляют    метода.
сигнатуру
12. Если методу передается значение типа int, то в этом случае используется передача
параметра по    .
значению
13. Создайте метод sum () с аргументами переменной длины для суммирования переда¬
ваемых ему значений типа int. Метод должен возвращать результат суммирования.
Продемонстрируйте его в действии.
Существует много вариантов решения данной задачи. Ниже представлен один из них.
Приложение А. Ответы на вопросы для самопроверки 571
class Sumlt {
int sum(int ... n) {
int result = 0;
for(int i = 0; i < n.length; i++)
result += n[i];
return result;
}
}
class SumDemo {
public static Void main(String args[]) {
Sumlt siObj = new Sumlt();
int total = siObj.sum(l, 2, 3);
System.out .println (1,Sum is " + total);
total = siObj.sum(l, 2, 3, 4, 5);
System.out.println("Sum is " + total);
}
}
14. Можно ли перегружать метод с аргументами переменной длины?
Да, можно.
15. Приведите пример неоднозначного вызова перегружаемого метода с переменным
числом аргументов.
Ниже приведен один из вариантов перегружаемого метода с переменным числом ар¬
гументов, при вызове которого проявляется неоднозначность.
double myMeth(double ... v ) { // ...
double myMeth(double d, double ... v) { // ...
Если попытаться вызвать метод myMeth () с одним аргументом следующим образом:
myMeth(1.1);
то компилятор не сможет определить, какой именно метод вызывается.

## Глава 7. Наследование
1.  Имеет ли суперкласс доступ к членам подкласса? Имеет ли подкласс доступ к чле¬
нам суперкласса?
Нет, не имеет. Суперклассу ничего не известно о существовании подклассов.
Подклассы действительно могут обращаться ко всем членам суперкласса, кроме тех,
которые объявлены как закрытые (private).
2.  Создайте подкласс Circle, производный от класса TwoDShape. В нем должен
быть определен метод area (), вычисляющий площадь круга, а также конструктор
с ключевым словом super для инициализации членов, унаследованных от класса
TwoDShape.
// Подкласс, производный от класса TwoDShape для формы круга,
class Circle extends TwoDShape {
// Конструктор по умолчанию
572 Java 7: руководство для начинающих, 5-е издание
Circle () {
super();
}
// Конструктор класса Circle
Circle(double х) {
super(x, "circle"); // вызвать конструктор суперкласса
}
// создать новый объект из имеющегося объекта
Circle(Circle ob) {
super(ob); // передать объект конструктору класса ?PwoDShape
}
double area () {
return (getWidth() /2) * (getWidth() / 2) * 3.1416;
}
}
3.  Как предотвратить обращение к членам суперкласса из подкласса?
Для того чтобы предотвратить доступ к членам суперкласса из подкласса, эти члены
следует объявить как закрытые (private).
4.  Опишите назначение и два варианта использования ключевого слова super.
Ключевое слово super используется в двух случаях. Во-первых, с его помощью вы¬
зывается конструктор суперкласса. В этом случае общая форма вызова имеет сле¬
дующий вид:
super (список_параметров) ;
И во-вторых, это ключевое слово обеспечивает доступ к членам суперкласса. Ниже
приведена общая форма такого доступа.
super.член_класса
5.  Допустим, имеется следующая иерархия классов:
class Alpha { ...
class Beta extends Alpha { ...
Class Gamma extends Beta { ...
В каком порядке вызываются конструкторы этих классов при создании объекта
класса Gamma?
Конструкторы всегда вызываются в порядке наследования. Таким образом, при
создании экземпляра класса Gamma будет сначала вызван конструктор Alpha, затем
Beta и, наконец, Gamma.
6.  Переменная ссылки на суперкласс может указывать на объект подкласса. Объясните,
почему это важно и как это связано с переопределением методов?
Когда переопределяемый метод вызывается по ссылке на суперкласс, его вариант
определяется по типу объекта, на который делается ссылка.
7.  Что такое абстрактный класс?
Приложение А. Ответы на вопросы для самопроверки 573
Абстрактным называется такой класс, который содержит хотя бы один абстрактный
метод.
8.  Как предотвратить переопределение метода? И как предотвратить наследование
класса?
Для того чтобы метод нельзя было переопределить, его нужно объявить как final.
А для того чтобы предотвратить наследование от класса, его следует объявить как
final.
9.  Объясните, каким образом механизмы наследования, переопределения методов и
абстрактные классы используются для поддержки полиморфизма.
Наследование, переопределение методов и абстрактные классы поддерживают по¬
лиморфизм и позволяют создать обобщенную структуру, реализуемую различными
классами. Так, абстрактный класс определяет согласованный интерфейс, общий для
всех реализующих его классов. Такой подход соответствует принципу “один интер¬
фейс — множество методов”.
10. Какой класс является суперклассом всех остальных классов?
Класс Object.
П. Класс, который содержит хотя бы один абстрактный метод, должен быть объявлен
абстрактным. Верно или не верно?
Верно.
12. Какое ключевое слово следует использовать для создания именованной константы?
Ключевое слово final.

## Глава 8. Пакеты и интерфейсы
1.  Используя код, созданный в примере для опробования 8.1, поместите в пакет qpack
интерфейс ICharQ и все три реализующие его класса. Класс IQDemo должен остать¬
ся в пакете, используемом по умолчанию. Покажите, как импортировать и исполь¬
зовать классы из пакета qpack.
Для того чтобы включить интерфейс ICharQ и реализующие его классы в пакет
qpack, следует поместить каждый из них в отдельный файл, объявить все классы,
реализующие данный интерфейс, как public, а в начале каждого файла ввести сле¬
дующий оператор:
package qpack;
После этого можно воспользоваться пакетом qpack, добавив в интерфейс IQDemo
следующий оператор import:
import qpack.*;
2.  Что такое пространство имен? Почему так важна возможность его разделения на от¬
дельные области в Java?
Пространство имен — это область объявлений. Разделяя пространство имен на от¬
дельные области, можно предотвратить конфликты имен.
3.  Содержимое пакетов хранится в   .
каталогах
574 Java 7: руководство для начинающих, 5-е издание
4.  В чем отличие доступа, определяемого ключевым словом protected, от доступа по
умолчанию?
Член класса с доступом типа protected может быть использован в пределах теку¬
щего пакета, а также в подклассах данного класса, относящихся к любому пакету.
А член класса с доступом по умолчанию может быть использован только в пределах
текущего пакета.
5.  Допустим, классы, содержащиеся в одном пакете, требуется использовать в другом
пакете. Какими двумя способами можно этого добиться?
Для того чтобы воспользоваться членом пакета, нужно указать его имя полностью
или же импортировать этот член с помощью оператора import.
6.  “Один интерфейс — множество методов” — главный принцип Java. Какое языковое
средство лучше всего демонстрирует этот принцип?
Этот принцип объектно-ориентированного программирования лучше всего демон¬
стрирует интерфейс.
7.  Сколько классов могут реализовать один и тот же интерфейс? Сколько интерфейсов
может реализовать класс?
Один интерфейс может быть реализован любым количеством классов. Класс может
реализовать произвольное число интерфейсов.
8.  Может ли один интерфейс наследовать другой интерфейс?
Да, может. Механизм наследования распространяется и на интерфейсы.
9.  Создайте интерфейс для класса Vehicle, рассмотренного в главе 7, назвав его
IVehicle.
interface IVehicle {
// возвратить дальность действия транспортного средства
int range();
// рассчитать объем топлива, требующегося
// для прохождения заданного пути
double fuelneeded(int miles);
// Методы доступа к переменным экземпляра.
int getPassengers();
void setPassengers(int p);
int getFuelcap();
void setFuelcap(int f);
int getMpg();
void setMpg(int m);
}
10. Переменные, объявленные в интерфейсе, неявно считаются как static и final.
Какие преимущества это дает?
Переменные, объявленные в интерфейсе, могут служить в качестве именованных
констант, общих для всех файлов программы. Доступ к ним обеспечивается путем
импорта того интерфейса, в котором они объявлены.
11. Пакет, по существу, является контейнером для классов. Верно или не верно?
Приложение А. Ответы на вопросы для самопроверки 575
Верно.
12. Какой стандартный пакет импортируется по умолчанию в любую программу на Java?
Пакет java.lang.

## Глава 9. Обработка исключений
1.  Какой класс находится на вершине иерархии исключений?
На вершине иерархии исключений находится класс Throwable.
2.  Объясните вкратце, как пользоваться ключевыми словами try и catch?
Ключевые слова try и catch используются совместно. Операторы программы для
отслеживания исключений помещаются в блок try. А перехват и обработка исклю¬
чений осуществляются в блоке catch.
3.  Какая ошибка допущена в приведенном ниже фрагменте кода?
II ...
vals[18] = 10;
catch (ArraylndexOutOfBoundsException exc) {
// обработать ошибку
}
Блоку catch не предшествует блок try.
4.  Что произойдет, если исключение не будет перехвачено?
Если исключение не будет перехвачено, произойдет аварийное завершение про¬
граммы.
5.  Какая ошибка допущена в приведенном ниже фрагменте кода?
class A extends Exception { ...
class В extends А { ...
II ...
try {
II ...
}
catch (A exc) { ... }
catch (B exc) { ... }
В данном фрагменте кода оператор catch для суперкласса предшествует оператору
catch для подкласса. А поскольку оператор catch для суперкласса может обрабо¬
тать также исключения, относящиеся к подклассу, то в программе окажется код, не¬
доступный для выполнения.
6.  Может ли внутренний блок catch повторно генерировать исключение, которое бу¬
дет обработано во внешнем блоке catch?
Да, исключения могут генерироваться повторно.
7.  Блок finally — последний фрагмент кода, выполняемый перед завершением про¬
граммы. Верно или неверно? Обоснуйте свой ответ.
Неверно. Блок finally выполняется по завершении блока try.
576 Java 7: руководство для начинающих, 5-е издание
8.  Исключения какого типа необходимо явно объявлять с помощью оператора throws,
включаемого в объявление метода?
С помощью оператора throws объявляются все исключения, кроме Runtime
Exception и Error.
9.  Какая ошибка допущена в приведенном ниже фрагменте кода?
class MyClass { // ... }
// ...
throw new MyClass();
Класс MyClass не является производным от класса Throwable. С помощью опера¬
тора throw могут генерироваться лишь те исключения, которые являются подклас¬
сами, производными от класса Throwable.
10. Отвечая на вопрос 3 упражнения для самопроверки по материалу главы 6, вы созда¬
ли класс Stack. Добавьте в него специальные исключения для реагирования на по¬
пытку поместить элемент в переполненный стек и извлечь элемент из пустого стека.
// Исключение, возникающее при переполнении стека,
class StackFullException extends Exception {
int size;
StackFullException (int s) { size = s; }
public String toString()    {
return "\nStack is full. Maximum size is " +
size;
}
}
// Исключение, возникающее при обращении к пустому стеку,
class StackEmptyException extends Exception {
public String toString ()   {
return "\nStack is empty.";
}
}
// Класс, реализующий стек для хранения символов,
class Stack {
private char stck[]; // Массив для хранения элементов стека
private int tos;    // Вершина стека
// построить пустой стек заданного размера
Stack(int size) {
stck = new char[size]; // выделить память для стека
tos = 0;
}
// построить один стек из другого стека
Stack(Stack ob) {
tos = ob.tos;
stck = new  char[ob.stck.length];
Приложение А. Ответы на вопросы для самопроверки 577
// скопировать элементы
for(int i=0; i < tos; i++)
stck[i] = ob.stck[i];
}
// построить стек с исходными значениями
Stack(char а [ ])   {
stck = new char[a.length];
for(int i = 0; i < a.length; i++)   {
try {
push (a [i]);
}
catch(StackFullException exc) {
System.out.println(exc);
}
}
}
// поместить символы в стек
void push(char ch) throws StackFullException {
if(tos==stck.length)
throw new StackFullException(stck.length);
stck[tos] = ch;
tos++;
}
// извлечь символы из стека
char pop() throws StackEmptyException {
if(tos==0)
throw new StackEmptyException();
tos — ;
return stck[tos];
}
}
11. Какими тремя способами можно сгенерировать исключение?
Исключение может быть сгенерировано в результате ошибки в виртуальной машине
Java, ошибки в программе или явным образом с помощью оператора throw.
12. Назовите два подкласса, производных непосредственно от класса Throwable.
Классы Error и Exception
13. Что такое многократный перехват?
Многократным называется такой перехват, который позволяет перехватывать два
и больше исключений одним оператором catch.
14. Следует ли перехватывать в программе исключения типа Error?
Нет, не следует.

## Глава 10. Ввод-вывод данных
1.  Для чего в Java определены как байтовые, так и символьные потоки?
Байтовые потоки с самого начала были определены в Java. Они особенно удобны
для ввода-вывода двоичных данных и поддерживают произвольный доступ к ним в
файлах. А символьные потоки оптимизированы для представления в уникоде.
2.  Как известно, ввод-вывод данных на консоль осуществляется в текстовом виде.
Почему же в Java для этой цели используются байтовые потоки?
Стандартные потоки ввода-вывода System, in, System.out и System.err были
определены в Java прежде символьных потоков.
3.  Как открыть файл для чтения байтов?
Ниже приведен один из способов открытия файла для ввода данных типа byte.
FilelnputStream fin = new FilelnputStream("test");
4.  Как открыть файл для чтения символов?
Ниже приведен один из способов открытия файла для ввода символов.
FileReader fr = new FileReader("test");
5.  Как открыть файл для ввода-вывода с произвольным доступом?
Ниже приведен один из способов открытия файла для ввода-вывода с произволь¬
ным доступом.
randfile = new RandomAccessFile("test", "rw");
6.  Как преобразовать числовую строку "123.23" в двоичный эквивалент?
Для того чтобы преобразовать числовую строку в двоичный эквивалент, следует вос¬
пользоваться одним из методов синтаксического анализа, определенных в классах
оболочек типов, например Integer или Double.
7.  Напишите программу, которая будет копировать текстовые файлы. Видоизмените ее
таким образом, чтобы все пробелы заменялись дефисами. Используйте при написа¬
нии программы классы, представляющие байтовые потоки, а также традиционный
способ закрытия файла явным вызовом метода close ().
/* Копирование текстового файла с заменой пробелов дефисами.
В этой версии программы используются байтовые потоки.
Для того чтобы воспользоваться этой программой, укажите
в командной строке имена исходного и целевого файлов. Например:
java Hyphen source target
*/
import java.io.*;
class Hyphen {
public static void main(String args[])
{
int i;
FilelnputStream fin = null;
FileOutputStream fout = null;
Приложение А. Ответы на вопросы для самопроверки 579
// проверить сначала, указаны ли оба файла
if(args.length !=2 ) {
System.out.println("Usage: Hyphen From To");
return;
}
// скопировать файл и заменить в нем пробелы дефисами
try {
fin = new FilelnputStream(args[0]);
fout = new FileOutputStream(args[1]);
do {
i = fin.read();
// преобразовать пробел в дефис
if((char)i == ' ') i =
if(i != -1) fout.write(i);
} while(i != -1);
} catch(IOException exc) {
System.out.println("I/O Error: " + exc);
} finally {
try {
if (fin != null) fin.closeO;
} catch(IOException exc) {
System.out.println("Error closing input file.");
}
try {
if(fin != null) fout.close();
} catch(IOException exc) {
System.out.println("Error closing output file.");
}
}
}
}
8.  Перепишите программу, созданную в ответ на предыдущий вопрос, таким обра¬
зом, чтобы в ней использовались классы, представляющие символьные потоки. На
этот раз воспользуйтесь оператором try с ресурсами для автоматического закры¬
тия файла.
/* Копирование текстового файла с заменой пробелов дефисами.
В этой версии программы используются символьные потоки.
Для того чтобы воспользоваться этой программой, укажите
в командной строке имена исходного и целевого файлов. Например:
java Hyphen2 source target
Для компиляции этого кода требуется JDK 7

или более поздняя версия данного комплекта.
*/
580 Java 7: руководство для начинающих, 5-е издание
import java.io.*;
class Hyphen2 {
public static void main(String args[])
throws IOException
{
int i;
// проверить сначала, указаны ли оба файла
if(args.length !=2 ) {
System.out.println("Usage: CopyFile From To");
return;
}
// скопировать файл и заменить в нем пробелы дефисами,
// используя оператор try с ресурсами
try (FileReader fin = new FileReader(args[0]);
FileWriter fout = new FileWriter(args[1]))
{
do {
i = fin.read();
// преобразовать пробел в дефис
if((char)i == • ') i =
if(i != -1) fout.write(i);
} while(i != —1);
} catch(IOException exc) {
System.out.println("I/O Error: " + exc);
}
}
}
9.  К какому типу относится поток System. in?
К типу InputStream.
10. Что возвращает метод read () из класса InputStream по достижении конца потока?
Значение -1.
11. Поток какого типа используется для чтения двоичных данных?
Поток типа DatalnputStream.
12. Классы Reader и Writer находятся на вершине иерархии классов
символьного ввода-вывода
13. Оператор try без ресурсов служит для    .
автоматического управления ресурсами
14. Если для закрытия файла используется традиционный способ, то это лучше всего
делать в блоке finally. Верно или неверно?
Верно.

## Глава 11. Многопоточное программирование
1.  Каким образом имеющиеся в Java средства многопоточного программирования по¬
зволяют писать более эффективные программы?
Средства многопоточного программирования дают возможность использовать пе¬
риоды простоя, наступающие практически в любой программе. Когда операции в
одном потоке по каким-то причинам не выполняются, в действие вступают другие
потоки. В многоядерных системах два и больше потоков могут исполняться одно¬
временно.
2.  Для поддержки многопоточного программирования в Java предусмотрен класс
    и интерфейс .
Для поддержки многопоточного программирования в Java предусмотрен класс
Thread и интерфейс Runnable.
3.  В каких случаях следует отдать предпочтение расширению класса Thread над реали¬
зацией интерфейса Runnable?
Подклассы, производные от класса Thread, целесообразно создавать в тех случа¬
ях, когда, помимо метода run (), требуется переопределить другие методы данного
класса.
4.  Покажите, как с помощью метода j о in () можно организовать ожидание заверше¬
ния потокового объекта MyThrd.
MyThrd.join()
5.  Покажите, как установить приоритет потока MyThrd на три уровня выше нормаль¬
ного приоритета.
MyThrd.setPriority(Thread.N0RM_PRI0RITY+3);
6.  Что произойдет, если в объявлении метода указать ключевое слово synchronized?
Если указать ключевое слово synchronized в объявлении метода, то в каждый мо¬
мент времени этот метод будет вызываться только в одном потоке для любого задан¬
ного объекта его класса.
7.  Методы wait () и notify () служат для   .
взаимодействия потоков
8.  Внесите в класс TickTock изменения для организации настоящего отчета времени.
Первую половину секунды должен занимать вывод на экран слова "Tick", а вто¬
рую — вывод слова "Tock". Таким образом, сообщение "Tick-Tock" должно соот¬
ветствовать одной секунде отсчитываемого времени. (Время переключения контек¬
стов можно не учитывать.)
Для организации отчета времени достаточно ввести в классе TickTock вызовы ме¬
тода sleep (), как показано ниже.
// Вариант класса TickTock, в который введены вызовы
// метода sleep() для организации отсчета времени.
class TickTock {
String state; // Состояние часов
synchronized void tick(boolean running) {
582 Javc,/: руководство для начинающих, 5-е издание
if(!running) { // остановить часы
state = "ticked";
notifyO; // уведомить ожидающие потоки
return;
}
System.out.print("Tick ");
// ожидать 1/2 секунды
try {
Thread.sleep(500);
} catch(InterruptedException exc) {
System.out.println("Thread interrupted.");
}
state = "ticked"; // установить текущее состояние после такта "тик"
notifyO; // разрешить выполнение метода tock()
try {
while(!state.equals("tocked"))
wait (); // ожидать завершения метода tock()
}
catch(InterruptedException exc) {
System.out.println("Thread interrupted.");
}
synchronized void tock(boolean running) {
if(!running) { // остановить часы
state = "tocked";
notifyO; // уведомить ожидающие потоки
return;
}
System.out.println("Tock");
// ожидать 1/2 секунды
try {
Thread.sleep(500);
} catch(InterruptedException exc) {
System.out.println("Thread interrupted.");
}
state = "tocked"; // установить текущее состояние после такта "так"
notifyO; // разрешить выполнение метода tick()
try {
while(!state.equals("ticked"))
wait (); // ожидать завершения метода tick()
}
catch(InterruptedException exc) {
System.out.println("Thread interrupted.");
}
Приложение А. Ответы на вопросы для самопроверки 583
}
}
9.  Почему в новых программах на Java не следует применять методы suspend (),
resume() и stop()?
Методы suspend (), resume () и stop () не рекомендуется применять, поскольку
они могут стать причиной серьезных осложнений при выполнении программы.
10. С помощью какого метода из класса Thread можно получить имя потока?
С помощью метода getName ().
11. Какое значение возвращает метод is Alive () ?
Он возвращает логическое значение true, если вызывающий поток исполняется,
или логическое значение false, если поток завершен.

## Глава 12. Перечисления, автоупаковка,
статический импорт и аннотации
1.  Константы перечислимого типа иногда называются самотипизированными. Что это
означает?
Часть “само” в термине самотипизированный означает тип перечисления, в котором
определена константа. Следовательно, константа перечислимого типа является объ¬
ектом того перечисления, в которое она входит.
2.  Какой класс автоматически наследуют перечисления?
Все перечисления наследуют от класса Enum.
3.  Напишите для приведенного ниже перечисления программу, в которой метод
values () служит для отображения списка констант и их значений.
enum Tools {
SCREWDRIVER, WRENCH, HAMMER, PLIERS
}
Это задание имеет следующее решение:
enum Tools {
SCREWDRIVER, WRENCH, HAMMER, PLIERS
}
class ShowEnum {
public static void main(String args[]) {
for(Tools d : Tools.values())
System.out.print(d + " has ordinal value of " +
d.ordinal() + '\n');
}
}
4.  Программу, имитирующую автоматизированный светофор и созданную в примере
для опробования 12.1, можно усовершенствовать, внеся ряд простых изменений,
чтобы выгодно воспользоваться возможностями перечислений. В исходной версии
этой программы продолжительность отображения каждого цвета светофора регу¬
лировалась в классе Traf ficLightSimulator, причем величины задержек были
жестко запрограммированы в методе run (). Измените исходный код программы
584 Jav\, 7: руководство для начинающих, 5-е издание
таким образом, чтобы продолжительность отображения каждого цвета светофора за¬
давалась константами перечислимого типа Traf f icLightColor. Для этого вам по¬
надобятся конструктор, переменная экземпляра, объявленная как private, а также
метод getDelay (). Подумайте о том, как еще можно улучшить данную программу.
(Подсказка: попробуйте отказаться от оператора switch и воспользоваться порядко¬
выми значениями каждого цвета для переключения светофора.)
Усовершенствованная версия программы, имитирующей работу светофора, приве¬
дена ниже. В нее внесены два существенных изменения. Во-первых, величина за¬
держки переключения связана теперь со значением перечислимого типа, что улуч¬
шает структуру кода. И во-вторых, в методе run () удалось обойтись без оператора
switch. Вместо этого методу sleep () теперь передается вызов tic. getDelay (), и
благодаря этому автоматически устанавливается задержка, соответствующая текуще¬
му цвету светофора.
// Усовершенствованная версия программы, имитирующей работу светофора.
// Величины задержки теперь хранятся в классе TrafficLightColor.
// Перечисление цветов переключения светофора,
enum TrafficLightColor {
RED(12000), GREEN(10000), YELLOW(2000);
private int delay;
TrafficLightColor(int d) {
delay = d;
}
int getDelay() { return delay; }
}
// Имитация автоматизированного светофора,
class TrafficLightSimulator implements Runnable {
private Thread thrd; // Поток для имитации светофора
private TrafficLightColor tic; // Текущее значение цвета
boolean stop = false; // Остановка имитации, если истинно
boolean changed = false; // Переключение светофора, если истинно
TrafficLightSimulator(TrafficLightColor init) {
tic = init;
thrd = new Thread(this);
thrd.start();
}
TrafficLightSimulator() {
tic = TrafficLightColor.RED;
thrd = new Thread(this);
thrd.start();
}
// Запуск имитации  автоматизированного светофора.
Приложение А. Ответы на вопросы для самопроверки 585
public void run() {
while(!stop) {
// По сравнению с предыдущей версией программы
// код значительно упростился!
try {
Thread.sleep(tlc.getDelay());
} catch(InterruptedException exc) {
System.out.println(exc);
}
changeColor ();
}
}
// Переключение цвета светофора,
synchronized void changeColor() {
switch(tic) {
case RED:
tic = TrafficLightColor.GREEN;
break;
case YELLOW:
tic = TrafficLightColor.RED;
break;
case GREEN:
tic = TrafficLightColor.YELLOW;
}
changed = true;
notify(); // уведомить о переключении цвета светофора
}
// Ожидание переключения цвета светофора,
synchronized void waitForChange() {
try {
while(!changed)
wait(); // ожидать переключения цвета светофора
changed = false;
} catch(InterruptedException exc) {
System.out.println(exc);
}
}
// Возврат текущего цвета.
TrafficLightColor getColor() {
return tic;
}
// Прекращение имитации светофора,
void cancel() {
stop = true;
586 Java 7: руководство для начинающих, 5-е издание
class TrafficLightDemo {
public static void main(String args[]) {
TrafficLightSimulator tl =
new TrafficLightSimulator(TrafficLightColor.GREEN);
for(int i=0; i < 9; i++) {
System.out.println(tl.getColor());
tl.waitForChange();
}
tl.cancel ();
}
}
5.  Что такое упаковка и распаковка? В каких случаях производится автоупаковка и ав¬
тораспаковка?
Упаковка означает включение значения простого типа в объект оболочки, а распа¬
ковка — извлечение значения из объекта оболочки. Автоупаковка означает автома¬
тическую упаковку значения без явного создания объекта, тогда как при автораспа¬
ковке значение простого типа автоматически извлекается из объекта оболочки без
явного вызова соответствующего метода, например intValue ().
6.  Измените следующий фрагмент кода таким образом, чтобы в нем производилась ав¬
тоупаковка:
Short val = new Short(123);
Это задание имеет следующее решение:
Short val = 123;
7.  Объясните, что такое статический импорт?
Статический импорт означает размещение статических членов класса или интер¬
фейса в глобальном пространстве имен. Это позволяет использовать статические
члены без указания имени соответствующего класса или интерфейса.
8.  Какие действия выполняет приведенный ниже оператор?
import static java.lang.Integer.parselnt;
Этот оператор помещает в глобальное пространство имен метод parselnt () из
класса оболочки типа Integer.
9.  Следует ли употреблять статический импорт от случая к случаю или желательно им¬
портировать статические члены всех классов?
Статический импорт уместен только в отдельных случаях. Если доступным окажется
слишком много статических членов, это может привести к конфликтам имен и на¬
рушению структуры кода.
10. Синтаксис аннотации основывается на .
интерфейсе
11. Какая аннотация называется маркером?
Маркер — это аннотация без аргументов.
12. Аннотации применимы только к методам. Верно или неверно?
Неверно. Любое объявление может быть аннотировано.

## Глава 13. Обобщения
1.  Обобщения очень важны, поскольку они позволяют создавать код, который:
а)  обеспечивает типовую безопасность;
б)  пригоден для повторного использования;
в)  отличается высокой надежностью;
г)  обладает всеми перечисленными выше свойствами.
Ответ: г) код обладает всеми перечисленными выше свойствами.
2.  Можно ли указывать простой тип в качестве аргумента типа?
Нет, нельзя. В качестве аргументов типа можно указывать только типы объектов.
3.  Как объявить класс FlightSched с двумя параметрами типа?
Это задание имеет следующее решение:
class FlightSched<T, V> {
4.  Измените ваш ответ на вопрос 3 таким образом, чтобы второй параметр типа обо¬
значал подкласс, производный от класса Thread.
Это задание имеет следующее решение:
class FlightSched<T, V extends Thread> {
5.  Внесите изменения в класс FlightSched таким образом, чтобы второй параметр
типа стал подклассом первого параметра типа.
Это задание имеет следующее решение:
class FlightSchedCT, V extends Т> {
6.  Что обозначает знак ? в обобщениях?
Знак ? обозначает метасимвольный аргумент, который соответствует любому допу¬
стимому типу.
7.  Может ли метасимвольный аргумент быть ограниченным?
Да. Метасимвольный аргумент может ограничиваться как сверху, так и снизу.
8.  У обобщенного метода My Gen () имеется один параметр типа, определяющий тип
передаваемого ему аргумента. Этот метод возвращает также объект, тип которого со¬
ответствует параметру типа. Как должен быть объявлен метод MyGen () ?
Это задание имеет следующее решение:
<Т> Т MyGen(Т о) {//.. .
9.  Допустим, обобщенный интерфейс объявлен так, как показано ниже,
interface IGenlFCT, V extends Т> { // ...
Составьте объявление класса MyClass, который реализует интерфейс I Gen IF.
Это задание имеет следующее решение:
class MyClass<T, V extends Т> implements IGenlFCT, V> { // ...
10. Допустим, имеется обобщенный класс Counter<T>. Как создать объект его базового
типа?
Для того чтобы получить базовый тип из обобщенного класса Counter<T>, доста¬
точно указать его имя, не обозначая тип, как показано ниже.
Counter х = new Counter;
588 Java 7r руководство для начинающих, 5-е издание
11. Существуют ли параметры типа на стадии выполнения программы?
Нет. Все параметры типа удаляются на стадии компиляции и заменяются соответ¬
ствующими приводимыми типами. Этот процесс называется стиранием.
12. Видоизмените ответ на вопрос 10 в упражнении по материалу главы 9 таким об¬
разом, чтобы сделать класс обобщенным. По ходу дела создайте интерфейс стека
IGenStack, объявив в нем обобщенные методы push () и pop ().
// Обобщенный стек.
interface IGenStack<T> {
void push(T obj) throws StackFullException;
T pop() throws StackEmptyException;
}
// Исключение, возникающее при переполнении стека,
class StackFullException extends Exception {
int size;
StackFullException(int s) { size = s; }
public String toString()    {
return "\nStack is full. Maximum size is " + size;
}
}
// Исключение, возникающее при обращении к пустому стеку,
class StackEmptyException extends Exception {
public String toString() {
return "\nStack is empty.”;
}
}
// Класс, реализующий стек для хранения объектов обобщенного типа,
class GenStack<T> implements IGenStack<T> {
private T stck[]; // Массив для хранения элементов стека
private int tos; // Вершина стека
// построить пустой стек заданного размера
GenStack(T[] stckArray) {
stck = stckArray;
tos = 0;
}
// построить один стек из другого стека
GenStack(T[] stckArray, GenStack<T> ob) {
tos = ob.tos;
stck = stckArray;
try {
Приложение А. Ответы на вопросы для самопроверки 589
if(stck.length < ob.stck.length)
throw new StackFullException(stck.length);
}
catch(StackFullException exc) {
System.out.println(exc);
}
// скопировать элементы
for(int i=0; i < tos; i++)  >
stck[i] = ob.stck[i];
}
// построить стек с исходными значениями
GenStack(T[] stckArray, Т[] а) {
stck = stckArray;
for(int i = 0; i < a.length; i++) {
try {
push(a [i]);
}
catch(StackFullException exc) {
System.out.println(exc);
}
}
}
// поместить объекты в стек
public void push(T obj) throws StackFullException {
if(tos==stck.length)
throw new StackFullException(stck.length);
stck[tos] = obj;
tos++;
}
// извлечь объекты из стека
public Т pop() throws StackEmptyException {
if(tos==0)
throw new StackEmptyException();
tos—;
return stck[tos];
}
}
// продемонстрировать применение класса GenStack
class GenStackDemo {
public static void main(String args[]) {
// создать пустой стек на 10 элементов типа Integer
Integer iStore[] = new Integer[10];
GenStack<Integer> stkl = new GenStack<Integer> (i'Store) ;
// построить стек из массива
590 Java 7: руководство для начинающих, 5-е издание
String name[] = {"One", "Two", "Three"};
String strStore[] = new String[3];
GenStack<String> stk2 =
new GenStack<String>(strStore, name);
String str;
int n;
try {
// поместить ряд значений в стек stkl
for(int i=0; i < 10; i++)
stkl.push(i);
} catch(StackFullException exc) {
System.out.println(exc);
}
// построить один стек из другого стека
String strStore2[] = new String[3];
GenStack<String> stk3 =
new GenStack<String>(strStore2, stk2);
try {
// отобразить стеки
System.out.print("Contents of stkl: ");
for(int i=0; i < 10; i++) {
n = stkl.pop();
System.out.print(n + " ");
}
System.out.println("\n");
System.out.print("Contents of stk2: ");
for(int i=0; i < 3; i++) {
str = stk2.pop();
System.out.print(str + " ");
}
System.out.println("\n");
System.out.print("Contents of stk3: ");
for(int i=0; i < 3; i++) {
str = stk3.pop();
System.out.print(str + " ");
}
} catch(StackEmptyException exc) {
System.out.println(exc);
}
System.out.println();
}
}
Приложение А. Ответы на вопросы для самопроверки 591
13. Что обозначают угловые скобки (< >)?
Угловые скобки обозначают ромбовидный оператор.
14. Как упростить приведенную ниже строку кода в версии JDK 7?
MyClass<Double,String> obj = new MyClass<Double,String>(1.1,"Hi");
Эту строку кода можно упростить, используя ромбовидный оператор следующим
образом:
MyClass<Double,String> obj = new MyClasso(1.1,"Hi");

## Глава 14. Апплеты, события и прочее
1.  Какой метод вызывается первым в начале выполнения апплета? Какой метод вызы¬
вается, когда апплет должен быть удален из системы?
Выполнение апплета начинается с вызова метода init (). А перед удалением аппле¬
та вызывается метод destroy ()..
2.  Почему в апплете, который должен работать постоянно, следует организовать мно¬
гопоточный режим?
Многопоточный режим необходим в постоянно выполняющемся апплете, пото¬
му что апплет — это управляемая событиями прикладная программа, в которой не
предусмотрены длительные операции. Например, метод paint () не будет вызван до
тех пор, пока метод start () не возвратит управление.
3.  Видоизмените апплет, созданный в примере для опробования 14.1, таким образом,
чтобы в нем отображалась символьная строка, передаваемая ему в качестве параме¬
тра. Добавьте еще один параметр, чтобы задавать время задержки (в миллисекундах)
между последовательными сдвигами символов строки.
/* Простой апплет, отображающий крупный
заголовок с использованием параметров.
*/
import java.awt.*;
import java.applet.*;
/*
<applet code="ParamBanner" width=300 height=50>
<param name=message value=" I like Java! ">
<param name=delay value=500>
</applet>
*/
public class ParamBanner extends Applet implements Runnable {
String msg;
int delay;
Thread t;
boolean stopFlag;
// инициализировать переменную t пустым значением null
public void init() {
String temp;
592 Java /.'руководство для начинающих, 5-е издание
msg = getParameter("message");
if(msg == null) msg = " Java Rules the Web ";
temp = getParameter("delay");
try {
if(temp != null)
delay = Integer.parselnt(temp);
else
delay =250; // Если параметр не задан,
// используется значение по умолчанию.
} catch(NumberFormatException exc) {
delay = 250 ; // Если допущена ошибка, используется
// значение по умолчанию.
}
t = null;
}
// запустить поток
public void start() {
t = new Thread(this);
stopFlag = false;
t. start();
}
// Точка входа в поток, манипулирующий крупным заголовком,
public void run() {
char ch;
// отобразить крупный заголовок снова
for( ; ; ) {
try {
repaint();
Thread.sleep(delay); *
ch = msg.charAt(0);
msg = msg.substring(1, msg.length());
msg += ch;
if (stopFlag)
break;
} catch(InterruptedException exc) {}
}
}
// остановить отображение крупного заголовка
public void stop() {
stopFlag = true;
t = null;
}
// отобразить крупный заголовок
public void paint(Graphics g) {
g.drawString(msg, 50, 30);
Приложение А. Ответы на вопросы для самопроверки 593.
}
}
4.  Дополнительное задание. Создайте апплет, который отображал бы текущее вре¬
мя, обновляя содержимое своего окна каждую секунду. Для того чтобы справить¬
ся с этим заданием, вам придется провести дополнительные изыскания. Для на¬
чала примите к сведению следующую подсказку: получить текущее время можно,
воспользовавшись объектом класса Calendar, относящегося к пакету java.util.
(Напомним, что компания Oracle предоставляет оперативно доступную документа¬
цию на все стандартные классы Java.) Приобретенных вами до сих пор знаний долж¬
но быть достаточно для того, чтобы самостоятельно изучить класс Calendar и ис¬
пользовать его методы для выполнения этого задания.
// Простой апплет, отображающий текущее время.
import java.util.*;
import java.awt.*;
import java.applet.*;
/*
<object code="Clock" width=200 height=50>
</object>
*/
public class Clock extends Applet implements Runnable {
String msg;
Thread t;
Calendar clock;
boolean stopFlag;
// инициализировать апплет
public void init() {
t = null;
msg =
}
// запустить поток
public void start() {
t = new Thread(this);
stopFlag = false;
t.start();
}
// Точка входа в поток, отображающий время,
public void run ()  {
// отобразить время повторно
for( ; ; )  {
try {
repaint();
Thread.sleep(1000);
if(stopFlag)
break;
} catch(InterruptedException exc) {}
}
}
// приостановить поток, отображающий время
public void stop () {
stopFlag = true;
t = null;
}
// отобразить время
public void paint(Graphics g) {
clock = Calendar.getlnstance();
msg = "Current time is " +
Integer.toString(clock.get(Calendar.HOUR));
msg = msg + ":" +
Integer.toString(clock.get(Calendar.MINUTE));
msg = msg + ":" +
Integer.toString(clock.get(Calendar.SECOND)); ч
g.drawString(msg, 30, 30);}
}
}
5.  Поясните вкратце, каким образом действует модель делегирования событий в Java.
В модели делегирования событий источник формирует событие и передает его одно¬
му или нескольким приемникам, которые лишь ожидают наступления события.
Получив уведомление, приемник обрабатывает событие, а затем возвращает управ¬
ление.
6.  Должен ли приемник событий быть зарегистрирован в их источнике?
Должен. Для того чтобы приемник получал уведомления о событиях, он должен
быть зарегистрирован в источнике.
7.  Дополнительное задание. Среди языковых средств Java для отображения инфор¬
мации имеется метод drawLine (). Он рисует текущим цветом прямую линию
между двумя точками. Этот метод относится классу Graphics. Используя метод
drawLine (), напишите апплет, отслеживающий перемещение мыши. Если кнопка
мыши нажата, апплет должен рисовать на экране непрерывную линию до тех пор,
пока кнопка не будет отпущена.
/* Отслеживание перемещения мыши путем рисования линии.
Признаками начала и конца линии являются нажатие
и отпускание кнопки мыши. */
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="TrackM" width=300 height=100>
</applet>
*/
public class TrackM extends Applet
implements MouseListener, MouseMotionListener {
Приложение А. Ответы на вопросы для самопроверки 595
int curX = 0, curY =0; // Текущие координаты
int oldX = 0, oldY =0; // Предыдущие координаты
boolean draw;
public void init () {
addMouseListener(this);
addMouseMotionListener(this);
draw = false;
}
/* Следующие три метода не используются, но их пустые реализации
нужны, так как эти методы объявлены в интерфейсе MouseListener. */
// обработать наведение курсора мыши на элемент
// пользовательского интерфейса
public void mouseEntered(MouseEvent me) {
}
// обработать отведение мыши от элемента
// пользовательского интерфейса
public void mouseExited(MouseEvent me) {
}
// обработать щелчок кнопкой мыши
public void mouseClicked(MouseEvent me) {
}
// обработать нажатие кнопки мыши
public void mousePressed(MouseEvent me) {
// сохранить координаты
oldX = me.getx();
oldY = me.getY();
, draw = true;
}
// обработать отпускание кнопки мыши
public void mouseReleased(MouseEvent me) {
draw = false;
}
// обработать перетаскивание мыши
public void mouseDragged(MouseEvent me) {
// сохранить координаты
curX = me.getx();
curY = me.getY();
repaint();
}
// обработать перемещение мыши
public void mouseMoved(MouseEvent me) {
// отобразить состояние
showStatus ("Moving mouse at " + me.getXO + ", " + me.getYO);
}
596 Java 71 руководство для начинающих, 5-е издание
// отобразить линию в окне апплета
public void paint(Graphics g) {
if(draw)
g.drawLine(oldX, oldY, curX, curY);
}
}
8.  Объясните назначение ключевого слова assert.
Ключевое слово assert создает утверждение, т.е. условие, которое должно быть ис¬
тинным при выполнении программы. Если же утверждение ложно, генерируется ис¬
ключение AssertionError.
9.  Приведите хотя бы одну причину, по которой может возникнуть потребность в ис¬
пользовании собственного метода в некоторых программах.
Собственный метод может понадобиться для сопряжения с подпрограммами, напи¬
санными на других языках программирования, или для оптимизации кода с учетом
конкретной среды исполнения.

## Глава 15. Введение в Swing
1.  Компоненты AWT являются тяжеловесными, а компоненты Swing —
легковесными
2.  Может ли изменяться стиль оформления компонента Swing? Если да, то какое сред¬
ство позволяет это сделать?
Да, может. Это позволяют сделать подключаемые стили оформления в Swing.
3.  Какой контейнер верхнего уровня чаще всего используется в приложениях?
Контейнер JFrame.
4.  Контейнер верхнего уровня содержит несколько панелей. На какой панели разме¬
щаются компоненты?
На панели содержимого.
5.  Как создать ссылку, отображающую сообщение "Select an entry from the
list" (Выберите элемент из списка)?
JLabel("Select an entry from the list")
6.  В каком потоке должно происходить все взаимодействие с компонентами графиче¬
ского пользовательского интерфейса?
В потоке диспетчеризации событий.
7.  Какая команда действия связывается по умолчанию с компонентом JButton? Как
изменить команду действия?
По умолчанию символьная строка команды действия содержит текст надписи на
кнопке. Команду действия можно изменить, вызвав метод setActionCommand ().
8.  Какое событие формируется при нажатии кнопки?
Событие ActionEvent.
9.  Как создать поле ввода текста шириной до 32 символов?
JTextField(32)
Приложение А. Ответы на вопросы для самопроверки 597.
10. Можно ли установить команду действия для компонента JTextField? Если можно,
то как это сделать?
Да, можно. Для этого достаточно вызвать метод setActionCommand ().
11. С помощью какого компонента Swing можно создать флажок? Какое событие фор¬
мируется при установке или сбросе флажка?
Флажок создается с помощью компонента JCheckBox. При установке или сбросе
флажка формируется событие ItemEvent.
12. Компонент JList отображает список элементов, которые может выбирать пользо¬
ватель. Верно или неверно?
Верно.
13. Какое событие формируется при выборе пользователем элемента из списка типа
JList или отмене выбора?
Событие ListSelectionEvent.
14. В каком методе задается режим выбора элементов списка типа JList? С помощью
какого метода можно получить индекс первого выбранного элемента?
Режим выбора элементов списка задается в методе setSelectionMode (). А метод
getSelectedlndex () возвращает индекс первого выбранного элемента.
15. Подкласс какого класса нужно создать при разработке Swing-апплета?
Подкласс JApplet.
16. Обычно при построении исходного пользовательского интерфейса в Swing-апплетах
используется метод invokeAndWait (). Верно или неверно?
Верно.
17. Добавьте в утилиту сравнения файлов, созданную в примере для опробования 15.1,
флажок со следующей пояснительной надписью: Show position of mismatch (Пока¬
зывать место несовпадения). Если этот флажок установлен, программа должна ото¬
бражать место, в котором обнаружено первое расхождение в содержимом сравнивае¬
мых файлов.
/*
Пример для опробования 15-1.
Утилита сравнения файлов, создаваемая на основе Swing.
В этой версии присутствует флажок для установки режима показа
места первого несовпадения содержимого сравниваемых файлов.
Для компиляции этой утилиты требуется JDK 7
или более поздняя версия данного комплекта.
*/
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
class SwingFC implements ActionListener {
598 Java 7: руководство для начинающих, 5-е издание
JTextField jtfFirst; // Переменная для хранения имени первого файла
JTextField jtfSecond; // Переменная для хранения имени второго файла
JButton jbtnComp; // Кнопка для сравнения файлов
JLabel jlabFirst, jlabSecond; // Подсказки для пользователя
JLabel jlabResult; // Сведения о результатах и сообщения об ошибках
JCheckBox jcbLoc; // флажок для показа места первого несовпадения
файлов
SwingFC () {
// создать новый контейнер JFrame
JFrame jfrm = new JFrame("Compare Files");
// установить диспетчер компоновки FlowLayout
j frm.setLayout(new FlowLayout());
// задать исходные размеры рамки окна
jfrm.setSize(200, 190);
// завершить программу после закрытия окна
j frm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
// создать поля для ввода имен файлов
jtfFirst = new JTextField(14);
jtfSecond = new JTextField(14);
// установить команды действия для полей ввода текста
jtfFirst.setActionCommand("fileA");
jtfSecond.setActionCommand("fileB");
// создать кнопку Compare
JButton jbtnComp = new JButton("Compare");
// добавить приемник событий действия от кнопки Compare
jbtnComp.addActionListener(this) ;
// создать метки
jlabFirst = new JLabel("First file: ");
jlabSecond = new JLabel("Second file: ");
jlabResult = new JLabel("");
// создать флажок
jcbLoc = new JCheckBox("Show position of mismatch");
// добавить компоненты на панели содержимого
jfrm.add(jlabFirst);
jfrm.add(jtfFirst) ;
jfrm.add(jlabSecond) ;
jfrm.add(jtfSecond);

j f rm.add(j cbLoc);
Приложение А. Ответы на вопросы для самопроверки 599.
jfrm.add(jbtnComp);
jfrm.add(jlabResult);
// отобразить рамку окна
j frm.setVisible(true);
}
// сравнить файлы после нажатия кнопки Compare
public void actionPerformed(ActionEvent ae) {
int i=0, j=0;
// сначала убедиться, что введены имена обоих файлов
if(jtfFirst.getText().equals("")) {
jlabResult.setText("First file name missing.");
return;.
}
if(jtfSecond.getText().equals("")) {
jlabResult.setText("Second file name missing.");
return;
// сравнить файлы, используя оператор try с ресурсами
try (FilelnputStream    fl  =   new FilelnputStream(jtfFirst.getText());
FilelnputStream f2  =   new FilelnputStream(jtfSecond.getText()))
// проверить содержимое каждого файла
do {
i = f1.read();
j = f2.read();
if(i != j) break;
}   whiled != -1 && j !=    -1) ;
if(i != j) (
if(jcbLoc.isSelected())
jlabResult.setText("Files differ at location " + count);
else
jlabResult.setText("Files are not the same.");
}
else
jlabResult.setText("Files compare equal.");
} catch(IOException exc) {
jlabResult.setText("File Error");
}
}
public static void main(String args[]) {
// создать рамку окна в потоке диспетчеризации событий
SwingUtilities.invokeLater(new Runnable() {
public void run() {
new SwingFC();
}
});
}
}
18. Измените программу List Demo таким образом, чтобы она допускала выбор не¬
скольких элементов из списка.
// Демонстрация выбора нескольких элементов из списка
// с помощью компонента Jlist.
// Для компиляции этой программы требуется JDK 7
// или более поздняя версия данного комплекта.
import javax.swing.*;
import javax.swing.event;
import java.awt.*;
import java.awt.event.*;
class ListDemo implements ListSelectionListener {
JList<String> jlst;
JLabel jlab;
JScrollPane jscrlp;
// создать массив имен
String names[] = { "Sherry", "Jon", "Rachel",
"Sasha", "Josselyn", "Randy",
"Tom", "Mary", "Ken",
"Andrew", "Matt", "Todd" };
ListDemo()  {
// создать новый контейнер JFrame
JFrame jfrm = new JFrame("JList Demo");
// установить диспетчер компоновки FlowLayout
j frm.setLayout(new FlowLayout());
// задать исходные размеры рамки окна
jfrm.setSize(200, 160);
// завершить программу после закрытия окна
j frm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
// создать компонент JList
jlst = new JList<String>(names);
// Удалив следующую строку кода, можно задать режим выбора
// нескольких элементов из списка, поскольку этот режим
// устанавливается для компонента JList по умолчанию.
// jlst.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
// добавить список на панели прокрутки,
jscrlp = new JScrollPane(jlst);
// задать предпочтительные размеры панели прокрутки
jscrlp.setPreferredSize(new Dimension(120, 90));
Приложение А. Ответы на вопросы для самопроверки
// создать метку для отображения результатов выбора из списка,
jlab = new JLabel("Please choose a name");
// добавить обработчик событий, связанных с выбором из списка
jlst.addListSelectionListener(this);
// добавить список и метку на панели содержимого
jfrm.add(jscrip);
jfrm.add(jlab);
// отобразить рамку окна
j frm.setVisible(true);
}
// обработать события, связанные с выбором элементов из списка
public void valueChanged(ListSelectionEvent le) {
// получить индексы тех элементов, выбор которых был сделан
// или отменен в списке
int indices[] = j1st.getSelectedlndices();
// отобразить результат выбора, если был выбран один
// или несколько элементов из списка
if(indices.length != 0) {
String who = "";
// построить символьную строку из выбранных имен
for(int i : indices)
who += names[i] + " ";
jlab.setText("Current selections: " + who);
}
else // иначе еще раз предложить сделать выбор
jlab.setText("Please choose a name");
public static void main(String args[]) {
// создать рамку окна в потоке диспетчеризации событий
SwingUtilities.invokeLater(new Runnable()   {
public void run() {
new ListDemo();
}
}) ;
}
}